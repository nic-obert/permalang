#pragma once

#include "pvm.hh"
#include "token.hh"


// PREDECLARATIONS

namespace syntax_tree { class SyntaxTree; };

std::ostream& operator<<(std::ostream& stream, const syntax_tree::SyntaxTree& tree);


namespace syntax_tree
{   

    #define DO_POP_SCOPE true
    #define DONT_POP_SCOPE false


    // linked list of Token organized in a tree-like fashion
    class Statement
    {
    public:

        Tokens::Token* root;

        Statement* next;


        Statement(Tokens::Token* root, Statement* next);
        Statement(Tokens::Token* root);
        Statement();


        void remove(Tokens::Token* token, bool del = false);


        Tokens::Token* getLast() const;

    };


    // linked list of Statement
    class Statements
    {
    public:

        Statement* start;
        Statement* end;


        Statements(Statement* statement);
        Statements();

        // removes the last statement of the linked list
        // does not delete it
        void removeLast();

        void add(Statement* statement);
    
    };


    typedef struct ControlFlowNode
    {
        pvm::ByteNode* byteNode;
        OpCodes opCode;

        ControlFlowNode(pvm::ByteNode* byteNode, OpCodes opCode);

    } ControlFlowNode;


    class SyntaxTree
    {
    private:

        pvm::ByteList byteList;

        Statements statements;

        // stores pointers to the ByteNodes of flow control operators such as
        // "break" and "continue"
        std::vector<ControlFlowNode> controlFlowNodes;


        // constructs the SyntaxTree of the given Statement
        void parseStatement(Statement* statement);

        // satisfy the requirements of a Token
        // add the generated byteCode to the tree's byteCode
        // generate SymbolTable entries for the evaluated symbols
        void satisfyToken(Statement* statement, Tokens::Token* token);

        // generate byte code for every Token in every Statement recursively
        // adds the generated byte code to the tree's byteList
        void generateByteCode();

        // generates the byte code for a Token operator
        // returns the stack pointer of the operation's result
        size_t byteCodeFor(Tokens::Token* token, Tokens::Token** operands, bool doStoreResult);

        // parses the Token operator and its operands recursively
        // generates byte code for the operator and its operands recursively
        // deletes the operands after byte code is generated
        // adds the generated byte code to the tree's byteList
        void parseTokenOperator(Tokens::Token* token);

        // parse the tree and generate byte code for it recursively
        // should not be accessible to the public 
        void parseToByteCodePrivate();


        friend std::ostream& ::operator<<(std::ostream& stream, const SyntaxTree&);


    public:
        
        SyntaxTree();
        SyntaxTree(Tokens::TokenList& tokens);
        SyntaxTree(Statements&& statements);
       
        // returns the token with the highest priority in the statement
        // does not check for empty statements
        Tokens::Token* getHighestPriority(Tokens::Token* root);

        pvm::ByteCode parseToByteCode();

    };


};


std::ostream& operator<<(std::ostream& stream, const syntax_tree::Statement& statement);

